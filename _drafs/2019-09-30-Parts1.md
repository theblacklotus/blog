---
layout: post
title:  "Making Eon: Effects Part 1"
author: Daniel Collin (emoon/TBL)
author_link: https://twitter.com/daniel_collin
---

# TBL Logo

To start of with we have the "classic" TBL logo as can be seen here.

<iframe align="middle" width="752" height="576" src="/assets/tbl_logo.mp4" frameborder="0"> </iframe>

The way the A1200 version worked was to have 40 images of 160x160 loaded to memory so they take ~1MB of memory which wouldn't work on an A500 that has much tighter memory constrains. What I instead did is to write a tool that scan each image and finds the starting and ending segments on each line and store only that. One frame when just plotting these positions looks like this

![tbl-logo-lines](/assets/tbl_logo_lines.png)

The way the data is layerd out is that I have as separate stream of the amount of "segments" for each line in a separate array. The reason to separate the data is that it allows for better compression as the numbers are repeating more. Then for each line (that has some data) I have a pair of two bytes for starting and ending positions. This brings the data needed from the full frames of 1MB to ~22KB (and 17K compressed on disk) It would likely be possible to bring this down even further by delta steps instead but this was good enough.

At the start of the effect I plot these dots using the CPU and then I have the Blitter filling the outline. In order to have as much CPU time as possible I pre-render all of the frames into 40 frames of one bitplane buffer. This way I only need to use the CPU once to plot the outline and during the part I can just rotate between the frames.

## "Motion Blur"

The A1200 version of this effect blends frames with the CPU by using [chunky to planar](http://oldwww.nvg.ntnu.no/amiga/amigafaq/AmigaFAQ_16.html) This would be too slow to do on the A500 (esp when we want to leave as much CPU time availible as possible) for the loading. So instead I use a "classic" trick of doing motion blur on Amiga which is pretty much free (disregarding the extra DMA time needed for bitplanes) and that is to use 4 bitplanes instead of one 1 and set up the palette in such way that the bitplanes will "blend" with each other. The way this works is that all frames are already generated so far example on frame N.

```
On N:

Bitplane 3 = Frame 4
Bitplane 2 = Frame 3
Bitplane 1 = Frame 2
Bitplane 0 = Frame 1

On N+1

Bitplane 3 = Frame 5
Bitplane 2 = Frame 4
Bitplane 1 = Frame 3
Bitplane 0 = Frame 2
```

As each bitplane with lower values has darker colors you get a "motion blur" like effect as the previous frame is shown darker and we have 4 frames of motion blur here. Now real motion blur of course doesn't work like this as you take the steps in between frames but the effect helps quite a bit by removing the otherwise harder look. See this video for a comparison. With the non-motion blurred version of the left and the original on the right.

<iframe align="middle" width="600" height="270" src="/assets/tbl_logo_compare.mp4"> </iframe>

## Glitching

There is a Glitch effect that happens now on then on the logo. The idea was to use this in more places in the demo but it turned out to be quite hard to get working many parts as in many cases we use the Copper to drive the Blitter to have as little stalls as possible on the CPU side. The glitching is done by a combination Blitter copies and Copper scrolling per line. Initially Calladin made a ref in After Effects and I manually looked at each frame and tried to re-create something similar.
First thing a bunch of frames gets slightly shifted with the Blitter and the palette is changd in order to apply the magenta / purple color shift. As the effect usually happens in x directly the blitter has to be used to apply this shift. If the shift would only have happened in y direction it would have been easier as only bitplane pointers would have been needed to change. I construct a number of `GlitchOp` tables that gets applied each frame for a total of 8 different glitch frames. A definition of frame can look like this

```c
static GlitchOp s_frame_4_ops[] = {
	{ .op.scroll = { 80, 0, 0, 0 }, .type = GlitchType_Scroll },
	{ .op.scroll = { 1, 7, 0, (GLITCH_WIDTH / 8)*85 }, .type = GlitchType_Scroll },
	{ .op.scroll = { 1, 8, 0, (GLITCH_WIDTH / 8)*90 }, .type = GlitchType_Scroll },
	{ .op.scroll = { 1, 1, 0, (GLITCH_WIDTH / 8)*95 }, .type = GlitchType_Scroll },
	{ .op.scroll = { 10, 0, 3, (GLITCH_WIDTH / 8)*99 }, .type = GlitchType_Scroll },
	{ .type = GlitchType_End },
};
```




